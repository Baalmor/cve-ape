import csv
import re
from collections import defaultdict
from logging import Logger
from os.path import dirname, getsize, isfile, join
from subprocess import PIPE, run

from cve_ape.cvedb import CVEDB
from cve_ape.error_handler import (
    EmptyTxtError,
    ErrorHandler,
    ErrorMode,
    InvalidListError,
)
from cve_ape.log import LOGGER
from cve_ape.util import ProductInfo, Remarks

ROOT_PATH = join(dirname(__file__), "..")


class PackageListParser:
    def __init__(
        self, input_file: str, logger: Logger = None, csv_format:str = None, error_mode=ErrorMode.TruncTrace
    ) -> None:
        self.input_file = input_file
        self.logger = logger or LOGGER.getChild(self.__class__.__name__)
        self.error_mode = error_mode
        self.csv_format = csv_format
        self.parsed_data_without_vendor = defaultdict(dict)
        self.parsed_data_with_vendor = defaultdict(dict)
        self.package_names_known = []
        self.package_names_unknown = []

    def process_file(self, input_file):
        packages = []
        with open(input_file) as req:
            lines = req.readlines()
        parser_re = re.compile(r"^(.*?)\-(?=(?:[0-9]+\.){0,}[0-9]+(?:-[a-z]+)?)(.*?)$")
        for line in lines:
            parse = parser_re.search(re.split("\n", line)[0])
            if parse is not None:
                packages.append({"name": parse[1], "version": parse[2]})
            else:
                self.logger.warning(f"Did not parsed: {line}")
        return packages

    def process_file_csv(self, input_file):
        packages = []
        self.logger.error("CSV parsing is not implemented")
        return packages

    def parse_list(self):
        input_file = self.input_file
        self.check_file()
        if self.csv_format is not None:
            packages = self.process_file_csv(input_file)
        else:
            packages = self.process_file(input_file)
        cve_db = CVEDB()
        self.package_names_known, self.package_names_unknown = cve_db.get_packages_from_pkglist(
            packages
        )

        #self.parse_data()
        return self.package_names_known

    def parse_data(self):
        for row in self.package_names_known:
            product_info = ProductInfo(
                row["vendor"], row["name"].lower(), row["version"]
            )
            self.parsed_data_with_vendor[product_info][
                row.get("cve_number", "").strip() or "default"
            ] = {
                "remarks": Remarks.NewFound,
                "comments": row.get("comments", "").strip(),
                "severity": row.get("severity", "").strip(),
            }
            self.parsed_data_with_vendor[product_info]["paths"] = {""}

    def check_file(self):
        input_file = self.input_file
        error_mode = self.error_mode

        if not isfile(input_file):
            with ErrorHandler(mode=error_mode):
                raise FileNotFoundError(input_file)

        if getsize(input_file) == 0:
            with ErrorHandler(mode=error_mode):
                raise EmptyTxtError(input_file)

        # TODO: Replace below error handling with a proper pip install dry run
        # See: https://github.com/pypa/pip/issues/53
        # if wrong
        #    with ErrorHandler(mode=error_mode):
        #        raise InvalidListError("Invalid Package list")
